<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>二维向量张成空间可视化 - 带网格控制</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0c1a3a, #152c57);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 20, 40, 0.85);
            border-bottom: 1px solid rgba(100, 180, 255, 0.3);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.4);
        }
        
        .header h1 {
            font-size: 2.4rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ffffff, #aaccff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
            letter-spacing: 1px;
        }
        
        .content-container {
            display: flex;
            flex: 1;
            padding: 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
            flex-direction: column;
            align-items: center;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            background: rgba(25, 50, 90, 0.85);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(100, 180, 255, 0.3);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .control-group label {
            margin-bottom: 5px;
            color: #aaccff;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider-container input[type="range"] {
            width: 150px;
        }
        
        .slider-value {
            width: 40px;
            text-align: center;
            background: rgba(0, 20, 40, 0.85);
            border-radius: 4px;
            padding: 2px 5px;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .visualization-container {
            width: 100%;
            height: 65vh;
            min-height: 450px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 0, 0, 0.1);
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
        }
        
        .info-text {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 10;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .legend {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 10;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .vector1-color { background: #1f77b4; }
        .vector2-color { background: #ff7f0e; }
        .result-color { background: #2ca02c; }
        .span-color { background: #9696ff; }
        
        .math-info {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border-radius: 8px;
            z-index: 10;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
            max-width: 300px;
            backdrop-filter: blur(5px);
        }
        
        .math-info h3 {
            color: #ffd166;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }
        
        .footer {
            text-align: center;
            padding: 15px;
            font-size: 0.9rem;
            color: rgba(200, 220, 255, 0.8);
            background: rgba(0, 10, 30, 0.7);
            border-top: 1px solid rgba(100, 180, 255, 0.2);
        }
        
        .decoration {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(100,180,255,0.15) 0%, rgba(100,180,255,0) 70%);
            pointer-events: none;
            z-index: 0;
        }
        
        .decoration:nth-child(1) {
            width: 200px;
            height: 200px;
            top: 10%;
            left: 5%;
            animation: float 15s ease-in-out infinite;
        }
        
        .decoration:nth-child(2) {
            width: 150px;
            height: 150px;
            bottom: 15%;
            right: 10%;
            animation: float 12s ease-in-out infinite;
            animation-delay: 2s;
        }
        
        .decoration:nth-child(3) {
            width: 120px;
            height: 120px;
            top: 40%;
            right: 20%;
            animation: float 10s ease-in-out infinite;
            animation-delay: 4s;
        }
        
        @keyframes float {
            0% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-15px) rotate(10deg); }
            100% { transform: translateY(0px) rotate(0deg); }
        }
        
        @media (max-width: 1000px) {
            .controls {
                gap: 10px;
            }
            
            .visualization-container {
                height: 60vh;
            }
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                flex-direction: row;
                flex-wrap: nowrap;
                overflow-x: auto;
                justify-content: flex-start;
                padding: 10px 5px;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            
            .controls::-webkit-scrollbar {
                display: none;
            }
            
            .control-group {
                flex: 0 0 auto;
                min-width: 150px;
            }
            
            .visualization-container {
                height: 55vh;
                min-height: 400px;
            }
            
            .math-info {
                max-width: 250px;
                font-size: 0.8rem;
            }
        }
        
        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.6rem;
            }
            
            .visualization-container {
                height: 50vh;
                min-height: 350px;
            }
            
            .math-info {
                max-width: 200px;
                padding: 8px;
                font-size: 0.7rem;
            }
            
            .math-info h3 {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <!-- 背景装饰元素 -->
    <div class="decoration"></div>
    <div class="decoration"></div>
    <div class="decoration"></div>
    
    <div class="header">
        <h1>二维向量张成空间可视化</h1>
    </div>
    
    <div class="content-container">
        <div class="controls">
            <div class="control-group">
                <label for="coeff1">系数 x₁:</label>
                <div class="slider-container">
                    <input type="range" id="coeff1" min="-5" max="5" step="0.1" value="1">
                    <span class="slider-value" id="coeff1-value">1.0</span>
                </div>
            </div>
            
            <div class="control-group">
                <label for="coeff2">系数 x₂:</label>
                <div class="slider-container">
                    <input type="range" id="coeff2" min="-5" max="5" step="0.1" value="1">
                    <span class="slider-value" id="coeff2-value">1.0</span>
                </div>
            </div>
            

            
            <div class="control-group" style="margin-left: 20px;">
                <div class="checkbox-container">
                    <input type="checkbox" id="show-result" checked>
                    <label for="show-result">显示线性组合结果</label>
                </div>
            </div>
            
            <div class="control-group">
                <div class="checkbox-container">
                    <input type="checkbox" id="show-parallelogram" checked>
                    <label for="show-parallelogram">显示平行四边形</label>
                </div>
            </div>
            
            <div class="control-group">
                <div class="checkbox-container">
                    <input type="checkbox" id="show-grid" checked>
                    <label for="show-grid">显示网格</label>
                </div>
            </div>
        </div>
        
        <div class="visualization-container">
            <div id="canvas-container"></div>
            <div class="info-text">提示: 滚轮缩放 | 双击重置视图</div>
            <div class="legend">
                <div class="legend-item"><div class="legend-color vector1-color"></div>向量 α (1, 1)</div>
                <div class="legend-item"><div class="legend-color vector2-color"></div>向量 β (2, -1)</div>
                <div class="legend-item"><div class="legend-color result-color"></div>线性组合结果</div>
            </div>
            
            <div class="math-info">
                <h3>当前线性组合</h3>
                <div id="current-equation">
                    <p>x₁·α + x₂·β = 结果</p>
                </div>
            </div>
        </div>
    </div>
    
    <div class="footer">
        <p>线性代数二维可视化 | 向量张成空间演示 | © 2025 数学可视化项目</p>
    </div>

    <script>
        // 初始化Three.js场景
        let scene, camera, renderer, sceneGroup;
        let vector1, vector2, resultVector;
        let spanPlane, spanLine;
        let gridHelper;
        let parallelogram; // 添加平行四边形对象
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let targetZoom = 10;
        let currentZoom = 10;
        
        // 新增向量对象
        let vectorV1, vectorV2, vectorV3;
        let vectorU1, vectorW2; // 新增向量对象
        
        // 悬停相关变量
        let currentHoveredHandle = null;
        
        // 拖动相关变量
        let isDraggingVector = false;
        let draggedVector = null;
        let dragOffset = new THREE.Vector3();
        
        // 向量定义 (二维)
        const α = new THREE.Vector3(1, 1, 0);
        const β = new THREE.Vector3(2, -1, 0);
        
        // 新增向量定义
        let v1 = new THREE.Vector3(3, 3, 0); // 3α
        let v2 = new THREE.Vector3(-1.75, -1.75, 0); // -7/4α
        let v3 = new THREE.Vector3(-2.25, -2.25, 0); // v1 + 3v2
        
        // 新增向量u₁和w₂的定义
        let u1 = new THREE.Vector3(2 * α.x - 3 * β.x, 2 * α.y - 3 * β.y, 0); // u₁ = 2α - 3β
        let w2 = new THREE.Vector3(1.5 * α.x + 0.5 * β.x, 1.5 * α.y + 0.5 * β.y, 0); // w₂ = 3/2α + 1/2β
        
        // 当前系数
        let coeff1 = 1.0;
        let coeff2 = 1.0;
        
        // 颜色定义
        const vector1Color = 0x1f77b4; // 蓝色
        const vector2Color = 0xff7f0e; // 橙色
        const resultColor = 0x2ca02c;   // 绿色
        const spanColor = 0x9696ff;     // 紫色
        
        // 新增向量颜色定义
        const v1Color = 0x0070b8; // (0, 112, 184)
        const v2Color = 0x00b3b0; // (0, 179, 176)
        const v3Color = 0xd40d8c; // (212, 13, 140)
        
        // 新增向量u₁和w₂的颜色定义
        const u1Color = 0x00b3b0; // (153, 50, 204) - 深紫色
        const w2Color = 0xd40d8c; // (220, 20, 60) - 深红色
        
        // 初始化场景
        function init() {
            // 创建场景 - 白色背景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            
            // 创建相机
            const container = document.querySelector('.visualization-container');
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 10);
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // 添加光源
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(1, 1, 1);
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight2.position.set(-1, -1, -1);
            scene.add(directionalLight2);
            
            // 创建场景组
            sceneGroup = new THREE.Group();
            scene.add(sceneGroup);
            
            // 添加基于v1和v2向量的网格辅助平面
            createVectorBasedGrid();
            
            // 创建图像边界
            createBoundary();
            
            // 创建坐标轴（黑色）
            createAxes();
            
            // 创建张成空间表示
            createSpanVisualization();
            
            // 创建平行四边形
            createParallelogram();
            
            // 创建向量（最后添加，确保在最上层）
            createVectors();
            
            // 添加事件监听器
            setupEventListeners();
            
            // 初始更新
            updateScene();
            updateLegend();
            
            // 开始动画循环
            animate();
        }
        
        // 创建坐标轴（带箭头和标签）
        function createAxes() {
            const axesGroup = new THREE.Group();
            const axisLength = 6;
            const axisColor = 0x000000; // 黑色坐标轴
            
            // 创建坐标轴函数
            const createAxis = (start, end, color) => {
                const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
                const material = new THREE.LineBasicMaterial({ color, linewidth: 5 });
                const line = new THREE.Line(geometry, material);
                line.renderOrder = 1; // 设置渲染顺序，确保在网格之上
                return line;
            };
            
            // X轴
            axesGroup.add(createAxis(new THREE.Vector3(-axisLength, 0, 0), new THREE.Vector3(axisLength, 0, 0), axisColor));
            // Y轴
            axesGroup.add(createAxis(new THREE.Vector3(0, -axisLength, 0), new THREE.Vector3(0, axisLength, 0), axisColor));
            
            // 在坐标轴端点处添加箭头（调整位置使其顶着边框）
            const arrow1 = createAxisArrow(new THREE.Vector3(1, 0, 0), new THREE.Vector3(axisLength, 0, 0), axisColor);
            arrow1.renderOrder = 1; // 设置渲染顺序，确保在网格之上
            axesGroup.add(arrow1);
            
            const arrow2 = createAxisArrow(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, axisLength, 0), axisColor);
            arrow2.renderOrder = 1; // 设置渲染顺序，确保在网格之上
            axesGroup.add(arrow2);
            
            sceneGroup.add(axesGroup);
            
            // 添加坐标轴标签（调整位置使其更靠近）
            const axisLengthLabel = 6.2;
            const xlabel = create3DAxisLabel('X', new THREE.Vector3(axisLengthLabel, 0, 0), '#000000');
            xlabel.renderOrder = 1; // 设置渲染顺序，确保在网格之上
            axesGroup.add(xlabel);
            
            const ylabel = create3DAxisLabel('Y', new THREE.Vector3(0, axisLengthLabel, 0), '#000000');
            ylabel.renderOrder = 1; // 设置渲染顺序，确保在网格之上
            axesGroup.add(ylabel);
        }
        
        // 创建坐标轴箭头（平面样式）
        function createAxisArrow(direction, position, color) {
            const arrowLength = 0.3; // 进一步缩小箭头长度
            const arrowHeadLength = 0.15; // 进一步缩小箭头头部长度
            const arrowHeadWidth = 0.1; // 进一步缩小箭头头部宽度
            
            // 创建箭头几何体（使用平面三角形突出显示）
            const geometry = new THREE.ConeGeometry(arrowHeadWidth, arrowHeadLength, 3);
            const material = new THREE.MeshBasicMaterial({ 
                color: color,
                side: THREE.DoubleSide
            });
            const arrowHead = new THREE.Mesh(geometry, material);
            
            // 调整箭头位置，使其位于坐标轴端点
            arrowHead.position.copy(position);
            
            // 根据方向旋转箭头
            const up = new THREE.Vector3(0, 1, 0);
            arrowHead.quaternion.setFromUnitVectors(up, direction);
            
            return arrowHead;
        }
        
        // 创建坐标轴标签
        function create3DAxisLabel(text, position, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 160;
            canvas.height = 160;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(0, 0, 0, 0)';
            context.fillRect(0, 0, 160, 160);
            context.font = 'Bold 48px Arial'; // 放大字体
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = color;
            context.fillText(text, 80, 80);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(1.0, 1.0, 1.0);
            sprite.renderOrder = 1; // 设置渲染顺序，确保在网格之上
            sprite.position.copy(position);
            return sprite;
        }
        
        // 创建向量
        function createVectors() {
            // 向量α (蓝色)
            const arrow1 = createVectorArrow(α, vector1Color);
            arrow1.userData = { type: 'vector', vector: α, index: 1 };
            sceneGroup.add(arrow1);
            vector1 = arrow1;
            
            // 向量β (橙色)
            const arrow2 = createVectorArrow(β, vector2Color);
            arrow2.userData = { type: 'vector', vector: β, index: 2 };
            sceneGroup.add(arrow2);
            vector2 = arrow2;
            
            // 新增向量 u₁ = 2α - 3β
            const arrowU1 = createVectorPoint(u1, u1Color, 'u₁');
            sceneGroup.add(arrowU1);
            vectorU1 = arrowU1;
            
            // 新增向量 w₂ = 3/2α + 1/2β
            const arrowW2 = createVectorPoint(w2, w2Color, 'w₂');
            sceneGroup.add(arrowW2);
            vectorW2 = arrowW2;
            
            // 结果向量 (绿色)
            const resultArrow = createVectorArrow(new THREE.Vector3(0, 0, 0), resultColor);
            sceneGroup.add(resultArrow);
            resultVector = resultArrow;
            
            // 设置结果向量的初始可见性
            resultVector.visible = document.getElementById('show-result').checked;
        }
        
        // 创建向量箭头（平面样式）
        function createVectorArrow(vector, color) {
            const group = new THREE.Group();
            
            // 箭头杆
            const direction = vector.clone().normalize();
            const length = vector.length();
            
            // 创建箭头杆
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(direction.x * length, direction.y * length, 0)
            ]);
            const lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 3 });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            line.renderOrder = 1; // 设置渲染顺序，确保在网格之上
            group.add(line);
            
            // 创建箭头头部（平面三角形）
            const headLength = 0.3; // 缩小箭头长度
            const headWidth = 0.2; // 缩小箭头宽度
            const coneGeometry = new THREE.ConeGeometry(headWidth, headLength, 3);
            const coneMaterial = new THREE.MeshBasicMaterial({ color: color });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
            cone.renderOrder = 1; // 设置渲染顺序，确保在网格之上
            
            // 定位箭头头部
            cone.position.copy(direction.clone().multiplyScalar(length - headLength/2));
            
            // 旋转箭头头部
            const up = new THREE.Vector3(0, 1, 0);
            cone.quaternion.setFromUnitVectors(up, direction);
            
            group.add(cone);
            
            // 创建可交互的平面圆点（位于向量末端）
            const circleGeometry = new THREE.CircleGeometry(0.15, 32); // 半径0.15，32段
            const circleMaterial = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide // 确保双面可见
            });
            const circle = new THREE.Mesh(circleGeometry, circleMaterial);
            circle.renderOrder = 1; // 设置渲染顺序，确保在网格之上
            circle.position.copy(direction.clone().multiplyScalar(length));
            // 确保圆点在XY平面上，沿X轴旋转-π/2
            circle.rotation.set(-Math.PI / 2, 0, 0);
            circle.userData = { type: 'vectorHandle' }; // 标记为向量手柄
            circle.visible = false; // 默认隐藏
            group.add(circle);
            
            // 向量标签
            const label = createVectorLabel(vector, color);
            label.renderOrder = 1; // 设置渲染顺序，确保在网格之上
            group.add(label);
            
            return group;
        }
        
        // 创建向量点（带标签）
        function createVectorPoint(vector, color, label) {
            const group = new THREE.Group();
            
            // 创建3D球体（回退到3D版本）
            const sphereGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const sphereMaterial = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.7
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.renderOrder = 1; // 设置渲染顺序，确保在网格之上
            sphere.position.copy(vector);
            group.add(sphere);
            
            // 创建标签
            const textCanvas = document.createElement('canvas');
            textCanvas.width = 300;
            textCanvas.height = 150;
            const context = textCanvas.getContext('2d');
            context.fillStyle = 'rgba(0, 0, 0, 0)';
            context.fillRect(0, 0, 300, 150);
            context.font = 'Bold 60px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = '#' + color.toString(16).padStart(6, '0');
            context.fillText(label, 150, 75);
            
            const texture = new THREE.CanvasTexture(textCanvas);
            const material = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(1.5, 0.75, 1.5);
            sprite.renderOrder = 1; // 设置渲染顺序，确保在网格之上
            
            // 将标签位置调整到圆点上方
            const labelPosition = vector.clone();
            labelPosition.y += 0.3; // 向上偏移
            sprite.position.copy(labelPosition);
            
            group.add(sprite);
            
            return group;
        }
        
        // 创建向量标签
        function createVectorLabel(vector, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 300;
            canvas.height = 150;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(0, 0, 0, 0)';
            context.fillRect(0, 0, 300, 150);
            context.font = 'Bold 60px Arial'; // 放大字体
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = '#' + color.toString(16).padStart(6, '0');
            
            // 根据向量确定标签文本
            let text = '';
            // 使用更精确的比较方法
            if (vector.equals(α)) {
                text = 'α';
            } else if (vector.equals(β)) {
                text = 'β';
            } else {
                text = '';
            }
            
            context.fillText(text, 150, 75);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(1.5, 0.75, 1.5);
            sprite.renderOrder = 1; // 设置渲染顺序，确保在网格之上
            
            // 将标签位置调整到向量线上方，避免重叠
            const labelPosition = vector.clone().multiplyScalar(0.5);
            // 向量方向的垂直向量（逆时针旋转90度）
            const perpendicular = new THREE.Vector3(-vector.y, vector.x, 0).normalize();
            // 将标签位置向上偏移
            labelPosition.add(perpendicular.multiplyScalar(0.3));
            sprite.position.copy(labelPosition);
            
            return sprite;
        }
        
        // 检查点是否在边界内
        function isPointInBoundary(point) {
            const boundarySize = 6; // 边界半长
            return Math.abs(point.x) <= boundarySize && Math.abs(point.y) <= boundarySize;
        }
        
        // 检查线段是否与边界相交或在边界内
        function isLineInBoundary(start, end) {
            // 如果两个端点都在边界内，则线段在边界内
            if (isPointInBoundary(start) && isPointInBoundary(end)) {
                return true;
            }
            
            // 边界定义
            const boundaryMin = -6;
            const boundaryMax = 6;
            
            // 检查线段是否与边界相交
            // 使用线段与轴对齐矩形的交点检测算法
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            
            // 避免除零错误
            if (dx === 0 && dy === 0) {
                return isPointInBoundary(start);
            }
            
            let tMin = 0;
            let tMax = 1;
            
            // 检查与垂直边界的交点
            if (dx !== 0) {
                const t1 = (boundaryMin - start.x) / dx;
                const t2 = (boundaryMax - start.x) / dx;
                
                const tMinX = Math.min(t1, t2);
                const tMaxX = Math.max(t1, t2);
                
                tMin = Math.max(tMin, tMinX);
                tMax = Math.min(tMax, tMaxX);
            } else {
                // 垂直线
                if (start.x < boundaryMin || start.x > boundaryMax) {
                    return false;
                }
            }
            
            // 检查与水平边界的交点
            if (dy !== 0) {
                const t1 = (boundaryMin - start.y) / dy;
                const t2 = (boundaryMax - start.y) / dy;
                
                const tMinY = Math.min(t1, t2);
                const tMaxY = Math.max(t1, t2);
                
                tMin = Math.max(tMin, tMinY);
                tMax = Math.min(tMax, tMaxY);
            } else {
                // 水平线
                if (start.y < boundaryMin || start.y > boundaryMax) {
                    return false;
                }
            }
            
            return tMin <= tMax;
        }
        
        // 计算线段与边界的交点
        function clipLineToBoundary(start, end) {
            const boundaryMin = -6;
            const boundaryMax = 6;
            
            // 使用Liang-Barsky算法裁剪线段
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            
            let t0 = 0.0;
            let t1 = 1.0;
            
            // 检查与垂直边界的交点
            if (dx !== 0) {
                const tMinX = (boundaryMin - start.x) / dx;
                const tMaxX = (boundaryMax - start.x) / dx;
                
                const tLeft = Math.min(tMinX, tMaxX);
                const tRight = Math.max(tMinX, tMaxX);
                
                t0 = Math.max(t0, tLeft);
                t1 = Math.min(t1, tRight);
            } else {
                // 垂直线
                if (start.x < boundaryMin || start.x > boundaryMax) {
                    return null; // 线段在边界外
                }
            }
            
            // 检查与水平边界的交点
            if (dy !== 0) {
                const tMinY = (boundaryMin - start.y) / dy;
                const tMaxY = (boundaryMax - start.y) / dy;
                
                const tBottom = Math.min(tMinY, tMaxY);
                const tTop = Math.max(tMinY, tMaxY);
                
                t0 = Math.max(t0, tBottom);
                t1 = Math.min(t1, tTop);
            } else {
                // 水平线
                if (start.y < boundaryMin || start.y > boundaryMax) {
                    return null; // 线段在边界外
                }
            }
            
            if (t0 > t1) {
                return null; // 线段在边界外
            }
            
            // 计算裁剪后的线段端点
            const clippedStart = new THREE.Vector3(
                start.x + t0 * dx,
                start.y + t0 * dy,
                0
            );
            
            const clippedEnd = new THREE.Vector3(
                start.x + t1 * dx,
                start.y + t1 * dy,
                0
            );
            
            return [clippedStart, clippedEnd];
        }
        
        // 创建基于v1和v2向量的网格
        function createVectorBasedGrid() {
            // 创建一个基于v1和v2向量的自定义网格
            const gridGroup = new THREE.Group();
            
            // 网格线的颜色（更浅的颜色）
            const gridColor = 0xeeeeee; // 统一的网格颜色
            
            // 创建网格线材质（复用材质以确保颜色一致）
            const gridMaterial = new THREE.LineBasicMaterial({ color: gridColor, linewidth: 0.5 });
            
            // 创建基于α和β的网格线
            for (let i = -10; i <= 10; i++) {
                for (let j = -10; j <= 10; j++) {
                    // α方向的线
                    const start1 = new THREE.Vector3(
                        i * α.x + j * β.x,
                        i * α.y + j * β.y,
                        0
                    );
                    const end1 = new THREE.Vector3(
                        (i + 1) * α.x + j * β.x,
                        (i + 1) * α.y + j * β.y,
                        0
                    );
                    
                    // 裁剪线段到边界内
                    const clipped1 = clipLineToBoundary(start1, end1);
                    if (clipped1) {
                        // 创建线几何体
                        const line1Geometry = new THREE.BufferGeometry().setFromPoints(clipped1);
                        // 所有网格线使用统一颜色，避免与坐标轴重叠导致颜色变深
                        const line1 = new THREE.Line(line1Geometry, gridMaterial);
                        line1.renderOrder = 0; // 设置渲染顺序，确保在向量之下
                        gridGroup.add(line1);
                    }
                    
                    // β方向的线
                    const start2 = new THREE.Vector3(
                        i * α.x + j * β.x,
                        i * α.y + j * β.y,
                        0
                    );
                    const end2 = new THREE.Vector3(
                        i * α.x + (j + 1) * β.x,
                        i * α.y + (j + 1) * β.y,
                        0
                    );
                    
                    // 裁剪线段到边界内
                    const clipped2 = clipLineToBoundary(start2, end2);
                    if (clipped2) {
                        const line2Geometry = new THREE.BufferGeometry().setFromPoints(clipped2);
                        // 所有网格线使用统一颜色，避免与坐标轴重叠导致颜色变深
                        const line2 = new THREE.Line(line2Geometry, gridMaterial);
                        line2.renderOrder = 0; // 设置渲染顺序，确保在向量之下
                        gridGroup.add(line2);
                    }
                }
            }
            
            gridHelper = gridGroup;
            sceneGroup.add(gridHelper);
        }
        
        // 创建图像边界
        function createBoundary() {
            // 创建一个边界框（只显示边框线条，不显示对角线）
            const boundaryGroup = new THREE.Group();
            const boundaryColor = 0x000000; // 黑色边界
            const halfSize = 6; // 边界半长
            
            // 创建四条边框线
            const createBoundaryLine = (start, end, color) => {
                const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
                const material = new THREE.LineBasicMaterial({ color, linewidth: 2 });
                return new THREE.Line(geometry, material);
            };
            
            // 上边框
            boundaryGroup.add(createBoundaryLine(
                new THREE.Vector3(-halfSize, halfSize, 0),
                new THREE.Vector3(halfSize, halfSize, 0),
                boundaryColor
            ));
            
            // 下边框
            boundaryGroup.add(createBoundaryLine(
                new THREE.Vector3(-halfSize, -halfSize, 0),
                new THREE.Vector3(halfSize, -halfSize, 0),
                boundaryColor
            ));
            
            // 左边框
            boundaryGroup.add(createBoundaryLine(
                new THREE.Vector3(-halfSize, -halfSize, 0),
                new THREE.Vector3(-halfSize, halfSize, 0),
                boundaryColor
            ));
            
            // 右边框
            boundaryGroup.add(createBoundaryLine(
                new THREE.Vector3(halfSize, -halfSize, 0),
                new THREE.Vector3(halfSize, halfSize, 0),
                boundaryColor
            ));
            
            sceneGroup.add(boundaryGroup);
        }
        
        // 创建平行四边形
        function createParallelogram() {
            // 创建一个透明的平行四边形来表示向量张成的区域
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.MeshBasicMaterial({
                color: spanColor,
                opacity: 0.3,
                transparent: true,
                side: THREE.DoubleSide  // 确保双面可见
            });
            
            parallelogram = new THREE.Mesh(geometry, material);
            sceneGroup.add(parallelogram);
        }
        
        // 创建张成空间可视化
        function createSpanVisualization() {
            // 创建一个平面来表示张成空间
            const planeGeometry = new THREE.PlaneGeometry(10, 10);
            const planeMaterial = new THREE.MeshPhongMaterial({
                color: spanColor,
                side: THREE.DoubleSide,
                opacity: 0.3,
                transparent: true,
                wireframe: false
            });
            spanPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            spanPlane.visible = false; // 默认隐藏
            sceneGroup.add(spanPlane);
            
            // 创建一条线来表示1维张成空间
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-5, -5, 0),
                new THREE.Vector3(5, 5, 0)
            ]);
            const lineMaterial = new THREE.LineBasicMaterial({
                color: spanColor,
                linewidth: 3
            });
            spanLine = new THREE.Line(lineGeometry, lineMaterial);
            spanLine.visible = false; // 默认隐藏
            sceneGroup.add(spanLine);
        }
        
        // 更新场景
        function updateScene() {
            // 获取当前系数
            coeff1 = parseFloat(document.getElementById('coeff1').value);
            coeff2 = parseFloat(document.getElementById('coeff2').value);
            
            // 更新滑块值显示
            document.getElementById('coeff1-value').textContent = coeff1.toFixed(1);
            document.getElementById('coeff2-value').textContent = coeff2.toFixed(1);
            
            // 计算线性组合结果
            const result = new THREE.Vector3(
                coeff1 * α.x + coeff2 * β.x,
                coeff1 * α.y + coeff2 * β.y,
                0
            );
            
            // 更新结果向量
            updateVectorArrow(resultVector, result, resultColor);
            
            // 更新张成空间可视化
            updateSpanVisualization();
            
            // 更新平行四边形
            updateParallelogram();
            
            // 更新数学表达式
            updateEquationDisplay(result);
        }
        
        // 更新向量箭头
        function updateVectorArrow(arrowGroup, vector, color) {
            // 移除旧的箭头和标签
            while(arrowGroup.children.length > 0) {
                arrowGroup.remove(arrowGroup.children[0]);
            }
            
            // 如果向量不为零向量，则创建新箭头
            if (vector.length() > 0.01) {
                const direction = vector.clone().normalize();
                const length = vector.length();
                
                // 创建箭头杆
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(direction.x * length, direction.y * length, 0)
                ]);
                const lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 3 });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                line.renderOrder = 1; // 设置渲染顺序，确保在网格之上
                arrowGroup.add(line);
                
                // 创建箭头头部（平面三角形）
                const headLength = 0.3; // 缩小箭头长度
                const headWidth = 0.2; // 缩小箭头宽度
                const coneGeometry = new THREE.ConeGeometry(headWidth, headLength, 3);
                const coneMaterial = new THREE.MeshBasicMaterial({ color: color });
                const cone = new THREE.Mesh(coneGeometry, coneMaterial);
                cone.renderOrder = 1; // 设置渲染顺序，确保在网格之上
                
                // 定位箭头头部
                cone.position.copy(direction.clone().multiplyScalar(length - headLength/2));
                
                // 旋转箭头头部
                const up = new THREE.Vector3(0, 1, 0);
                cone.quaternion.setFromUnitVectors(up, direction);
                
                arrowGroup.add(cone);
                
                // 创建可交互的3D球体（位于向量末端）
                const sphereGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const sphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.7
                });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.renderOrder = 1; // 设置渲染顺序，确保在网格之上
                sphere.position.copy(direction.clone().multiplyScalar(length));
                sphere.userData = { type: 'vectorHandle' }; // 标记为向量手柄
                sphere.visible = false; // 默认隐藏
                arrowGroup.add(sphere);
                
                // 添加标签
                const label = createVectorLabel(vector, color);
                arrowGroup.add(label);
            } else {
                // 即使向量为零，也添加一个非常小的点来表示向量存在
                const dotGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0)]);
                const dotMaterial = new THREE.PointsMaterial({ color: color, size: 0.1 });
                const dot = new THREE.Points(dotGeometry, dotMaterial);
                dot.renderOrder = 1; // 设置渲染顺序，确保在网格之上
                arrowGroup.add(dot);
                
                // 添加手柄（使用3D球体）
                const sphereGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const sphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.7
                });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.renderOrder = 1; // 设置渲染顺序，确保在网格之上
                sphere.position.set(0, 0, 0);
                sphere.userData = { type: 'vectorHandle' }; // 标记为向量手柄
                sphere.visible = false; // 默认隐藏
                arrowGroup.add(sphere);
            }
        }
        
        // 更新张成空间可视化
        function updateSpanVisualization() {
            // 隐藏所有张成空间表示
            spanPlane.visible = false;
            spanLine.visible = false;
        }
        
        // 鼠标按下事件
        function onMouseDown(event) {
            // 只有在悬停在手柄上时才能拖拽
            if (currentHoveredHandle) {
                isDraggingVector = true;
                
                // 查找手柄所属的向量
                let parent = currentHoveredHandle.parent;
                while (parent && !parent.userData.type) {
                    parent = parent.parent;
                }
                
                if (parent) {
                    draggedVector = parent;
                }
                
                // 获取鼠标位置
                const mouse = new THREE.Vector2();
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                // 创建射线
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                // 创建一个平面用于投影（z=0平面）
                const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                const intersection = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersection);
                
                // 计算偏移量
                dragOffset.copy(intersection).sub(currentHoveredHandle.getWorldPosition(new THREE.Vector3()));
                
                // 阻止默认行为
                event.preventDefault();
            }
        }
        
        // 鼠标移动事件
        function onMouseMove(event) {
            if (isDraggingVector && draggedVector) {
                // 获取鼠标位置
                const mouse = new THREE.Vector2();
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                // 创建射线
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                // 创建一个平面用于投影（z=0平面）
                const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                const intersection = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersection);
                
                // 计算新的向量位置
                const newPosition = intersection.sub(dragOffset);
                
                // 更新向量
                if (draggedVector === vector1) {
                    α.copy(newPosition);
                    updateVectorArrow(vector1, α, vector1Color);
                } else if (draggedVector === vector2) {
                    β.copy(newPosition);
                    updateVectorArrow(vector2, β, vector2Color);
                }
                
                // 更新新增向量
                updateAdditionalVectors();
                
                // 更新网格
                updateGrid();
                
                // 确保网格可见性状态正确
                if (gridHelper) {
                    gridHelper.visible = document.getElementById('show-grid').checked;
                }
                
                // 更新平行四边形
                updateParallelogram();
                
                // 更新图例
                updateLegend();
                
                // 更新结果向量
                updateScene();
                
                // 强制重新渲染场景
                renderer.render(scene, camera);
                
                // 阻止默认行为
                event.preventDefault();
            }
        }
        
        // 鼠标悬停事件
        function onHover(event) {
            // 获取鼠标位置
            const mouse = new THREE.Vector2();
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // 创建射线
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // 检查是否悬停在向量手柄上
            const intersects = raycaster.intersectObjects([vector1, vector2], true);
            
            // 隐藏所有手柄
            [vector1, vector2].forEach(vector => {
                if (vector) {
                    vector.children.forEach(child => {
                        if (child.userData.type === 'vectorHandle') {
                            child.visible = false;
                            child.scale.set(1, 1, 1);
                        }
                    });
                }
            });
            
            // 如果悬停在手柄上，显示并放大它
            let hoveredHandle = null;
            if (intersects.length > 0 && !isDraggingVector) {
                intersects.forEach(intersect => {
                    let object = intersect.object;
                    // 查找手柄对象
                    while (object && object.userData.type !== 'vectorHandle') {
                        object = object.parent;
                    }
                    
                    if (object && object.userData.type === 'vectorHandle') {
                        // 显示手柄
                        object.visible = true;
                        // 放大手柄
                        object.scale.set(1.5, 1.5, 1.5);
                        hoveredHandle = object;
                    }
                });
            }
            
            // 保存悬停的手柄引用
            currentHoveredHandle = hoveredHandle;
        }
        
        // 鼠标抬起事件
        function onMouseUp(event) {
            isDraggingVector = false;
            draggedVector = null;
        }
        
        // 更新新增向量
        function updateAdditionalVectors() {
            // 更新 v₁ = 3α
            v1 = new THREE.Vector3(3 * α.x, 3 * α.y, 0);
            if (vectorV1) {
                sceneGroup.remove(vectorV1);
                vectorV1 = createVectorPoint(v1, v1Color, 'v₁');
                sceneGroup.add(vectorV1);
            }
            
            // 更新 v₂ = -7/4α
            v2 = new THREE.Vector3(-1.75 * α.x, -1.75 * α.y, 0);
            if (vectorV2) {
                sceneGroup.remove(vectorV2);
                vectorV2 = createVectorPoint(v2, v2Color, 'v₂');
                sceneGroup.add(vectorV2);
            }
            
            // 更新 v₃ = v₁ + 3v₂
            v3 = new THREE.Vector3(v1.x + 3 * v2.x, v1.y + 3 * v2.y, 0);
            if (vectorV3) {
                sceneGroup.remove(vectorV3);
                vectorV3 = createVectorPoint(v3, v3Color, 'v₃');
                sceneGroup.add(vectorV3);
            }
            
            // 更新 u₁ = 2α - 3β
            u1 = new THREE.Vector3(2 * α.x - 3 * β.x, 2 * α.y - 3 * β.y, 0);
            if (vectorU1) {
                sceneGroup.remove(vectorU1);
                vectorU1 = createVectorPoint(u1, u1Color, 'u₁');
                sceneGroup.add(vectorU1);
            }
            
            // 更新 w₂ = 3/2α + 1/2β
            w2 = new THREE.Vector3(1.5 * α.x + 0.5 * β.x, 1.5 * α.y + 0.5 * β.y, 0);
            if (vectorW2) {
                sceneGroup.remove(vectorW2);
                vectorW2 = createVectorPoint(w2, w2Color, 'w₂');
                sceneGroup.add(vectorW2);
            }
        }
        
        // 更新网格
        function updateGrid() {
            // 保存当前网格可见性状态
            let gridVisible = true;
            if (gridHelper) {
                gridVisible = gridHelper.visible;
                sceneGroup.remove(gridHelper);
            }
            
            // 保存向量引用
            const tempVector1 = vector1;
            const tempVector2 = vector2;
            const tempVectorV1 = vectorV1;
            const tempVectorV2 = vectorV2;
            const tempVectorV3 = vectorV3;
            const tempVectorU1 = vectorU1; // 新增向量
            const tempVectorW2 = vectorW2; // 新增向量
            const tempResultVector = resultVector;
            
            // 如果向量存在，先移除它们
            if (vector1) sceneGroup.remove(vector1);
            if (vector2) sceneGroup.remove(vector2);
            if (vectorV1) sceneGroup.remove(vectorV1);
            if (vectorV2) sceneGroup.remove(vectorV2);
            if (vectorV3) sceneGroup.remove(vectorV3);
            if (vectorU1) sceneGroup.remove(vectorU1); // 新增向量
            if (vectorW2) sceneGroup.remove(vectorW2); // 新增向量
            if (resultVector) sceneGroup.remove(resultVector);
            
            // 创建新网格
            createVectorBasedGrid();
            
            // 恢复网格可见性状态
            if (gridHelper) {
                gridHelper.visible = gridVisible;
            }
            
            // 重新添加向量，确保它们在最上层
            if (tempVector1) sceneGroup.add(tempVector1);
            if (tempVector2) sceneGroup.add(tempVector2);
            if (tempVectorV1) sceneGroup.add(tempVectorV1);
            if (tempVectorV2) sceneGroup.add(tempVectorV2);
            if (tempVectorV3) sceneGroup.add(tempVectorV3);
            if (tempVectorU1) sceneGroup.add(tempVectorU1); // 新增向量
            if (tempVectorW2) sceneGroup.add(tempVectorW2); // 新增向量
            if (tempResultVector) sceneGroup.add(tempResultVector);
        }
        
        // 更新图例显示
        function updateLegend() {
            const legend = document.querySelector('.legend');
            legend.innerHTML = `
                <div class="legend-item"><div class="legend-color vector1-color"></div>向量 α (${α.x.toFixed(2)}, ${α.y.toFixed(2)})</div>
                <div class="legend-item"><div class="legend-color vector2-color"></div>向量 β (${β.x.toFixed(2)}, ${β.y.toFixed(2)})</div>
                <div class="legend-item"><div class="legend-color" style="background:#9932cc"></div>向量 u₁ (${u1.x.toFixed(2)}, ${u1.y.toFixed(2)})</div>
                <div class="legend-item"><div class="legend-color" style="background:#dc143c"></div>向量 w₂ (${w2.x.toFixed(2)}, ${w2.y.toFixed(2)})</div>
                <div class="legend-item"><div class="legend-color result-color"></div>线性组合结果</div>
            `;
        }
        
        // 更新平行四边形
        function updateParallelogram() {
            // 计算平行四边形的四个顶点
            // 顶点1: 原点 (0, 0)
            // 顶点2: α向量的系数倍
            // 顶点3: β向量的系数倍
            // 顶点4: α向量和β向量系数倍的和（即线性组合结果）
            
            const vertex1 = new THREE.Vector3(0, 0, 0);
            const vertex2 = new THREE.Vector3(coeff1 * α.x, coeff1 * α.y, 0);
            const vertex3 = new THREE.Vector3(coeff2 * β.x, coeff2 * β.y, 0);
            const vertex4 = new THREE.Vector3(
                coeff1 * α.x + coeff2 * β.x,
                coeff1 * α.y + coeff2 * β.y,
                0
            );
            
            // 创建平行四边形的顶点数组（两个三角形组成一个四边形）
            const vertices = new Float32Array([
                vertex1.x, vertex1.y, vertex1.z,
                vertex2.x, vertex2.y, vertex2.z,
                vertex3.x, vertex3.y, vertex3.z,
                
                vertex2.x, vertex2.y, vertex2.z,
                vertex3.x, vertex3.y, vertex3.z,
                vertex4.x, vertex4.y, vertex4.z
            ]);
            
            // 更新几何体
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.computeVertexNormals();
            
            // 替换旧几何体
            parallelogram.geometry.dispose();
            parallelogram.geometry = geometry;
            
            // 设置可见性
            parallelogram.visible = document.getElementById('show-parallelogram').checked;
        }
        
        // 更新数学表达式显示
        function updateEquationDisplay(result) {
            const equationElement = document.getElementById('current-equation');
            equationElement.innerHTML = `
                <p>${coeff1.toFixed(1)}·α + ${coeff2.toFixed(1)}·β =</p>
                <p>(${result.x.toFixed(2)}, ${result.y.toFixed(2)})</p>
            `;
        }
        
        // 设置事件监听器
        function setupEventListeners() {
            // 滑块事件
            document.getElementById('coeff1').addEventListener('input', updateScene);
            document.getElementById('coeff2').addEventListener('input', updateScene);
            
            // 复选框事件
            document.getElementById('show-result').addEventListener('change', function() {
                if (resultVector) {
                    resultVector.visible = this.checked;
                }
            });
            document.getElementById('show-grid').addEventListener('change', function() {
                if (gridHelper) {
                    gridHelper.visible = this.checked;
                }
            });
            document.getElementById('show-parallelogram').addEventListener('change', function() {
                if (parallelogram) {
                    parallelogram.visible = this.checked;
                }
            });
            
            const canvas = renderer.domElement;
            
            // 向量拖动事件
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseUp);
            
            // 鼠标悬停事件
            canvas.addEventListener('mousemove', onHover);
            
            // 缩放控制
            canvas.addEventListener('wheel', function(e) {
                e.preventDefault();
                targetZoom += e.deltaY * 0.01;
                // 限制缩放范围，适合高清晰度显示
                targetZoom = Math.max(5, Math.min(15, targetZoom));
            });
            
            // 重置视图
            canvas.addEventListener('dblclick', function() {
                targetZoom = 10;
            });
            
            // 窗口大小调整
            window.addEventListener('resize', function() {
                const container = document.querySelector('.visualization-container');
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 平滑缩放
            currentZoom += (targetZoom - currentZoom) * 0.1;
            camera.position.z = currentZoom;
            
            renderer.render(scene, camera);
        }
        
        // 初始化应用
        init();
    </script>
</body>
</html>